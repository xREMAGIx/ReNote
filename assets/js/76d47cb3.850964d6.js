"use strict";(self.webpackChunkrenote=self.webpackChunkrenote||[]).push([[2492],{8238:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var r=a(5893),n=a(3905);const i={sidebar_position:3},s="State-based Convergent Replicated Data Type (CvRDT)",o={id:"crdt/state-based-crdt",title:"State-based Convergent Replicated Data Type (CvRDT)",description:"Figures",source:"@site/docs/crdt/state-based-crdt.mdx",sourceDirName:"crdt",slug:"/crdt/state-based-crdt",permalink:"/docs/crdt/state-based-crdt",draft:!1,unlisted:!1,editUrl:"https://github.com/xREMAGIx/renote/tree/main/docs/crdt/state-based-crdt.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Objects and Operations",permalink:"/docs/crdt/objects-and-operations"},next:{title:"Operation-based Commutative Replicated Data Type (CmRDT)",permalink:"/docs/crdt/op-based-crdt"}},c={},d=[{value:"Figures",id:"figures",level:2},{value:"Definition",id:"definition",level:2},{value:"Deep Dive",id:"deep-dive",level:2}];function p(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",img:"img",p:"p",strong:"strong",...(0,n.ah)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"state-based-convergent-replicated-data-type-cvrdt",children:"State-based Convergent Replicated Data Type (CvRDT)"}),"\n",(0,r.jsx)(t.h2,{id:"figures",children:"Figures"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"State-based Replication",src:a(6378).Z+"",width:"772",height:"315"})}),"\n",(0,r.jsx)(t.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"State-based CRDTs (also called state-based replicated data types or state-based CRDTs)"})," do not rely on operations. Instead, each replica maintains a copy of the entire data structure, and updates are propagated to other replicas by exchanging the entire state of the data structure. The state of the data structure on each replica is merged using a merge function, which takes the states from two replicas and combines them into a new state that represents the merged state of the two replicas."]}),"\n",(0,r.jsx)(t.h2,{id:"deep-dive",children:"Deep Dive"}),"\n",(0,r.jsx)(t.p,{children:"In state-based (or passive) replication, an update occurs entirely at the source, then propagates by transmitting the modified payload between replicas, as illustrated above."}),"\n",(0,r.jsxs)(t.p,{children:["We specify state-based object types as shown in Specification 1. Keyword\xa0",(0,r.jsx)(t.em,{children:"payload"}),"\xa0indicates the payload type, and\xa0initial\xa0specifies its initial value at every replica. Keyword\xa0update\xa0indicates an update operation, and\xa0query\xa0a query. Both may have (optional) arguments and return values. Non-mutating statements are marked\xa0let, and payload is mutated by assignment :=. An operation executes atomically."]}),"\n",(0,r.jsx)(t.p,{children:"To capture safety, an operation is enabled only if a given\xa0source pre-condition\xa0(marked\xa0pre\xa0in a specification) holds in the source's current state. The source pre-condition is omitted if always enabled, e.g., incrementing or decrementing a Counter. Conversely, non-null pre- conditions may be necessary, for instance an element can be removed from a Set only if it is in the Set at the source."}),"\n",(0,r.jsx)(t.p,{children:"The system transmits state between arbitrary pairs of replicas, in order to propagate changes. This updates the payload of the receiver with the output of operation\xa0merge, invoked with two arguments, the local payload state and the received state. Operation\xa0compare\xa0compares replica states, as will be explained shortly."}),"\n",(0,r.jsxs)(t.p,{children:["Ref: ",(0,r.jsx)(t.a,{href:"https://inria.hal.science/inria-00555588/document",children:"A comprehensive study of Convergent and Commutative Replicated Data Types"})]})]})}function l(e={}){const{wrapper:t}={...(0,n.ah)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},3905:(e,t,a)=>{a.d(t,{ah:()=>d});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=r.createContext({}),d=function(e){var t=r.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},l=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,c=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),u=d(a),h=n,m=u["".concat(c,".").concat(h)]||u[h]||p[h]||i;return a?r.createElement(m,s(s({ref:t},l),{},{components:a})):r.createElement(m,s({ref:t},l))}));l.displayName="MDXCreateElement"},6378:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/stateBasedReplication-0d53be60cd36aefc01c6e2959a176406.png"}}]);