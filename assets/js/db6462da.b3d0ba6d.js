"use strict";(self.webpackChunkrenote=self.webpackChunkrenote||[]).push([[2042],{3683:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>a});var r=t(5893),o=t(1151);const i={sidebar_position:7},c="Counter CRDTs",s={id:"crdt/counter-crdts",title:"Counter CRDTs",description:"A Counter is a replicated integer supporting operations increment and decrement to update it, and value to query it. The semantics should be is that the value converge towards the global number of increments minus the number of decrements. (Extension to operations for adding and subtracting an argument is straightforward.)",source:"@site/docs/crdt/counter-crdts.mdx",sourceDirName:"crdt",slug:"/crdt/counter-crdts",permalink:"/renote/docs/crdt/counter-crdts",draft:!1,unlisted:!1,editUrl:"https://github.com/xREMAGIx/renote/tree/main/docs/crdt/counter-crdts.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Types Of CRDT",permalink:"/renote/docs/crdt/types-of-crdt"},next:{title:"Register CRDTs",permalink:"/renote/docs/crdt/register-crdts"}},d={},a=[{value:"State-based increment-only Counter (Growing-only Counter: G-Counter)",id:"state-based-increment-only-counter-growing-only-counter-g-counter",level:2},{value:"Scenario",id:"scenario",level:3},{value:"Example code",id:"example-code",level:3},{value:"Sample scenario",id:"sample-scenario",level:3},{value:"Increment/decrement Counter (Positive-Negative Counters: PN-Counter)",id:"incrementdecrement-counter-positive-negative-counters-pn-counter",level:2},{value:"Scenario",id:"scenario-1",level:3},{value:"Example code",id:"example-code-1",level:3},{value:"Sample scenario",id:"sample-scenario-1",level:3}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"counter-crdts",children:"Counter CRDTs"}),"\n",(0,r.jsx)(n.p,{children:"A Counter is a replicated integer supporting operations increment and decrement to update it, and value to query it. The semantics should be is that the value converge towards the global number of increments minus the number of decrements. (Extension to operations for adding and subtracting an argument is straightforward.)"}),"\n",(0,r.jsx)(n.p,{children:"A Counter CRDT is useful in many peer-to-peer applications, for instance counting the number of currently logged-in users."}),"\n",(0,r.jsx)(n.h2,{id:"state-based-increment-only-counter-growing-only-counter-g-counter",children:"State-based increment-only Counter (Growing-only Counter: G-Counter)"}),"\n",(0,r.jsx)(n.h3,{id:"scenario",children:"Scenario"}),"\n",(0,r.jsx)(n.p,{children:'For instance to count the number of clicks on a link in a P2P-replicated web page, or a P2P "I Like It/I Don\'t Like It" poll, as is common in social networks, or it could be a page view counter.'}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsx)(n.p,{children:"Suppose the payload was a single integer and merge computes max. This data type is a CvRDT as its states form a monotonic semilattice. Consider two replicas, with the same initial state of 0; at each one, a client originates increment. They converge to 1 instead of the expected 2."}),(0,r.jsx)(n.p,{children:"Suppose instead the payload is an integer and merge adds the two values. This is not a CvRDT, as merge is not idempotent."})]}),"\n",(0,r.jsx)(n.h3,{id:"example-code",children:"Example code"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type GCounter = Map<ReplicaId, number>;\n\nconst zero: GCounter = new Map<ReplicaId, number>();\n\nfunction value(c: GCounter): number {\n  let result = 0;\n  for (const [, v] of c) {\n    result += v;\n  }\n  return result;\n}\n\nfunction inc(r: ReplicaId, c: GCounter): GCounter {\n  const current = c.get(r) ?? 0;\n  const updated = current + 1;\n  return c.set(r, updated);\n}\n\nfunction merge(a: GCounter, b: GCounter): GCounter {\n  const merged = new Map<ReplicaId, number>();\n  for (const [ka, va] of a) {\n    const vb = b.get(ka);\n    if (vb !== undefined) {\n      merged.set(ka, Math.max(va, vb));\n    } else {\n      merged.set(ka, va);\n    }\n  }\n  for (const [kb, vb] of b) {\n    if (!merged.has(kb)) {\n      merged.set(kb, vb);\n    }\n  }\n  return merged;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"How the code works:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"GCounter"})," module defines a type ",(0,r.jsx)(n.code,{children:"GCounter"})," which is a map of ",(0,r.jsx)(n.code,{children:"ReplicaId"})," to ",(0,r.jsx)(n.code,{children:"int64"})," values. It also defines a ",(0,r.jsx)(n.code,{children:"zero"})," value of type ",(0,r.jsx)(n.code,{children:"GCounter"}),", which is an empty map."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"value"})," function takes a ",(0,r.jsx)(n.code,{children:"GCounter"})," and returns the sum of all the values in the map."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"inc"})," function takes a ",(0,r.jsx)(n.code,{children:"ReplicaId"})," and a ",(0,r.jsx)(n.code,{children:"GCounter"}),", and increments the value associated with that ",(0,r.jsx)(n.code,{children:"ReplicaId"})," in the map. If the ",(0,r.jsx)(n.code,{children:"ReplicaId"})," is not already in the map, it adds it with a value of 1."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"merge"})," function takes two ",(0,r.jsx)(n.code,{children:"GCounter"})," maps and returns a new ",(0,r.jsx)(n.code,{children:"GCounter"})," map that merges the two inputs. It does this by iterating over each key-value pair in the first map (",(0,r.jsx)(n.code,{children:"a"}),"), and updating the value in the second map (",(0,r.jsx)(n.code,{children:"b"}),") if the key already exists in ",(0,r.jsx)(n.code,{children:"b"}),", or adding the key-value pair to ",(0,r.jsx)(n.code,{children:"b"})," if it doesn't already exist. The value for the key is the maximum of the values from the two maps."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"sample-scenario",children:"Sample scenario"}),"\n",(0,r.jsxs)(n.p,{children:["If we have two ",(0,r.jsx)(n.code,{children:"GCounter"})," maps:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'a = {"replica1": 3, "replica2": 2, "replica3": 1}\nb = {"replica1": 2, "replica2": 3, "replica4": 1}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["When we call ",(0,r.jsx)(n.code,{children:"merge a b"}),", we get the following result:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'{"replica1": 3, "replica2": 3, "replica3": 1, "replica4": 1}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here, the value for ",(0,r.jsx)(n.code,{children:'"replica1"'})," is 3 because it is the maximum of 3 in ",(0,r.jsx)(n.code,{children:"a"})," and 2 in ",(0,r.jsx)(n.code,{children:"b"}),". The value for ",(0,r.jsx)(n.code,{children:'"replica2"'})," is 3 because it is the maximum of 2 in ",(0,r.jsx)(n.code,{children:"a"})," and 3 in ",(0,r.jsx)(n.code,{children:"b"}),". The values for ",(0,r.jsx)(n.code,{children:'"replica3"'})," and ",(0,r.jsx)(n.code,{children:'"replica4"'})," are simply copied from ",(0,r.jsx)(n.code,{children:"a"})," and ",(0,r.jsx)(n.code,{children:"b"}),", respectively, since they only exist in one of the maps."]}),"\n",(0,r.jsx)(n.h2,{id:"incrementdecrement-counter-positive-negative-counters-pn-counter",children:"Increment/decrement Counter (Positive-Negative Counters: PN-Counter)"}),"\n",(0,r.jsx)(n.h3,{id:"scenario-1",children:"Scenario"}),"\n",(0,r.jsx)(n.p,{children:"For instance, to count the number of users logged in to a P2P application such as Skype. To avoid excessively large vectors, only super-peers would replicate the counter. Due to asynchrony, the count may diverge temporarily from its true value, but it will eventually be exact."}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.p,{children:["It is not straightforward to support ",(0,r.jsx)(n.code,{children:"decrement"})," with the previous representation, because this operation would violate monotonicity of the semilattice. Furthermore, since ",(0,r.jsx)(n.code,{children:"merge"})," is a max operation, decrement would have no effect."]}),(0,r.jsxs)(n.p,{children:["Our solution, PN-Counter basically combines two G-Counters. Its payload consists of two vectors: ",(0,r.jsx)(n.code,{children:"P"})," to register ",(0,r.jsx)(n.code,{children:"increments"}),", and ",(0,r.jsx)(n.code,{children:"N"})," for ",(0,r.jsx)(n.code,{children:"decrements"}),". Its value is the difference between the two corresponding G-Counters, its partial order is the conjunction of the corresponding partial orders, and ",(0,r.jsx)(n.code,{children:"merge"})," merges the two vectors."]})]}),"\n",(0,r.jsx)(n.h3,{id:"example-code-1",children:"Example code"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { GCounter } from "./GCounter";\n\nexport type PNCounter = [GCounter, GCounter];\n\nexport const zero: PNCounter = [GCounter.zero, GCounter.zero];\n\nexport const value = ([inc, dec]: PNCounter): number => {\n  return GCounter.value(inc) - GCounter.value(dec);\n};\n\nexport const inc = (replica: string, [inc, dec]: PNCounter): PNCounter => {\n  return [GCounter.inc(replica, inc), dec];\n};\n\nexport const dec = (replica: string, [inc, dec]: PNCounter): PNCounter => {\n  return [inc, GCounter.inc(replica, dec)];\n};\n\nexport const merge = (\n  [inc1, dec1]: PNCounter,\n  [inc2, dec2]: PNCounter\n): PNCounter => {\n  return [GCounter.merge(inc1, inc2), GCounter.merge(dec1, dec2)];\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"How the code works:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["First, we define a type ",(0,r.jsx)(n.code,{children:"PNCounter"})," that is a tuple of two GCounters (",(0,r.jsx)(n.code,{children:"GCounter.GCounter * GCounter.GCounter"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["We define a ",(0,r.jsx)(n.code,{children:"zero"})," value for ",(0,r.jsx)(n.code,{children:"PNCounter"}),", which is a tuple of two empty GCounters."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["We define a ",(0,r.jsx)(n.code,{children:"value"})," function that takes a PNCounter and returns the difference between the value of the first GCounter and the value of the second GCounter."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["We define an ",(0,r.jsx)(n.code,{children:"inc"})," function that takes a replica and a PNCounter, and returns a new PNCounter with the replica's count incremented in the first GCounter."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["We define a ",(0,r.jsx)(n.code,{children:"dec"})," function that takes a replica and a PNCounter, and returns a new PNCounter with the replica's count incremented in the second GCounter."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["We define a ",(0,r.jsx)(n.code,{children:"merge"})," function that takes two PNCounters and returns a new PNCounter with the merged values of the two input PNCounters. This is done by merging the first GCounters together and merging the second GCounters together separately."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"sample-scenario-1",children:"Sample scenario"}),"\n",(0,r.jsx)(n.p,{children:'Sure, let\'s say you have a PNCounter with two replicas: "Replica1" and "Replica2". Initially, the PNCounter is set to zero, so the value of the PNCounter is 0.'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"let pnCounter: PNCounter = PNCounter.zero;\n"})}),"\n",(0,r.jsx)(n.p,{children:'Now, let\'s increment the counter by 1 on "Replica1":'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'pnCounter = PNCounter.inc("Replica1", pnCounter);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The PNCounter is now ",(0,r.jsx)(n.code,{children:"(GCounter { Replica1 => 1 }, GCounter {})"}),", because we incremented the ",(0,r.jsx)(n.code,{children:"inc"}),' counter on "Replica1" by 1.']}),"\n",(0,r.jsx)(n.p,{children:'Let\'s decrement the counter by 1 on "Replica2":'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'pnCounter = PNCounter.dec("Replica2", pnCounter);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The PNCounter is now ",(0,r.jsx)(n.code,{children:"(GCounter { Replica1 => 1 }, GCounter { Replica2 => 1 })"}),", because we incremented the ",(0,r.jsx)(n.code,{children:"dec"}),' counter on "Replica2" by 1.']}),"\n",(0,r.jsxs)(n.p,{children:["If we calculate the value of the PNCounter using PNCounter.value(pnCounter), we get ",(0,r.jsx)(n.code,{children:"-1"}),". This is because we decremented the counter once and didn't increment it again, so the current value is ",(0,r.jsx)(n.code,{children:"-1"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Now let's merge two PNCounters from different replicas:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'let pnCounter1: PNCounter = PNCounter.zero;\npnCounter1 = PNCounter.inc("Replica1", pnCounter1);\npnCounter1 = PNCounter.inc("Replica1", pnCounter1);\npnCounter1 = PNCounter.inc("Replica2", pnCounter1);\nlet pnCounter2: PNCounter = PNCounter.zero;\npnCounter2 = PNCounter.inc("Replica2", pnCounter2);\npnCounter2 = PNCounter.inc("Replica2", pnCounter2);\npnCounter2 = PNCounter.inc("Replica1", pnCounter2);\nlet merged = PNCounter.merge(pnCounter1, pnCounter2);\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"pnCounter1"})," is ",(0,r.jsx)(n.code,{children:"(GCounter { Replica1 => 2, Replica2 => 1 }, GCounter {})"}),". ",(0,r.jsx)(n.code,{children:"pnCounter2"})," is ",(0,r.jsx)(n.code,{children:"(GCounter { Replica2 => 2, Replica1 => 1 }, GCounter {})"}),". ",(0,r.jsx)(n.code,{children:"merged"})," is ",(0,r.jsx)(n.code,{children:"(GCounter { Replica1 => 2, Replica2 => 2 }, GCounter {})"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["As you can see, the ",(0,r.jsx)(n.code,{children:"inc"})," and ",(0,r.jsx)(n.code,{children:"dec"})," counters are merged independently. So in the ",(0,r.jsx)(n.code,{children:"merged"})," PNCounter, the ",(0,r.jsx)(n.code,{children:"inc"}),' counter for "Replica1" is 2 (because "Replica1" incremented twice in ',(0,r.jsx)(n.code,{children:"pnCounter1"})," and once in ",(0,r.jsx)(n.code,{children:"pnCounter2"}),"), the ",(0,r.jsx)(n.code,{children:"inc"}),' counter for "Replica2" is 2 (because "Replica2" incremented twice in ',(0,r.jsx)(n.code,{children:"pnCounter2"})," and once in ",(0,r.jsx)(n.code,{children:"pnCounter1"}),"), and the ",(0,r.jsx)(n.code,{children:"dec"})," counters are both zero, because neither replica decremented the counter. If we calculate the value of the ",(0,r.jsx)(n.code,{children:"merged"})," PNCounter using ",(0,r.jsx)(n.code,{children:"PNCounter.value(merged)"}),", we get 4."]})]})}function u(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>c});var r=t(7294);const o={},i=r.createContext(o);function c(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);