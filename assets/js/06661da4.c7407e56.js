"use strict";(self.webpackChunkrenote=self.webpackChunkrenote||[]).push([[286],{9434:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var s=t(5893),i=t(1151);const r={sidebar_position:8},a="Register CRDTs",c={id:"crdt/register-crdts",title:"Register CRDTs",description:"Last-Writer-Win Register (LWW Register)",source:"@site/docs/crdt/register-crdts.mdx",sourceDirName:"crdt",slug:"/crdt/register-crdts",permalink:"/renote/docs/crdt/register-crdts",draft:!1,unlisted:!1,editUrl:"https://github.com/xREMAGIx/renote/tree/main/docs/crdt/register-crdts.mdx",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Counter CRDTs",permalink:"/renote/docs/crdt/counter-crdts"},next:{title:"Set CRDTs",permalink:"/renote/docs/crdt/set-crdts"}},o={},d=[{value:"Last-Writer-Win Register (LWW Register)",id:"last-writer-win-register-lww-register",level:2},{value:"Scenario",id:"scenario",level:3},{value:"Example code",id:"example-code",level:3},{value:"Sample scenario",id:"sample-scenario",level:3},{value:"Multi Value Register (MV Register)",id:"multi-value-register-mv-register",level:2},{value:"Example code",id:"example-code-1",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"register-crdts",children:"Register CRDTs"}),"\n",(0,s.jsx)(n.h2,{id:"last-writer-win-register-lww-register",children:"Last-Writer-Win Register (LWW Register)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"LWW Register",src:t(3477).Z+"",width:"956",height:"349"}),"\nInteger LWW Register (state-based)"]}),"\n",(0,s.jsxs)(n.p,{children:["Ref: ",(0,s.jsx)(n.a,{href:"https://inria.hal.science/inria-00555588/document",children:"A comprehensive study of Convergent and Commutative Replicated Data Types"})]}),"\n",(0,s.jsx)(n.h3,{id:"scenario",children:"Scenario"}),"\n",(0,s.jsx)(n.p,{children:"Last write wins is a popular way of dealing with conflicts being the result of concurrent updates in many systems (Cassandra is good example of a database that's quite known from this approach)."}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"One of the issues of last-write-wins approach is its inherent risk of data loss - we took an easy to use API at price of automatically throwing out potentially useful data."})}),"\n",(0,s.jsx)(n.h3,{id:"example-code",children:"Example code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'type Timestamp = [timestamp: Date, replicaId: string];\n\ntype LWWRegister<T> = {\n  Timestamp: Timestamp;\n  Value: T | null;\n};\n\ntype Operation<T> = [dateTime: Date, value: T | null];\n\ntype Endpoint<T> = CRDT.Endpoint<\n  LWWRegister<T>,\n  T | null,\n  T | null,\n  Operation<T>\n>;\n\nconst crdt: CRDT.Crdt<\n  LWWRegister<unknown>,\n  unknown | null,\n  unknown | null,\n  Operation<unknown>\n> = {\n  Default: {\n    Timestamp: [new Date(-8640000000000000), ""],\n    Value: null,\n  },\n  Query: (crdt) => crdt.Value,\n  Prepare: (_, value) => [new Date(), value],\n  Effect: (existing, e) => {\n    const [at, value] = e.Data;\n    const timestamp: Timestamp = [at, e.Origin];\n    if (existing.Timestamp < timestamp) {\n      return { Timestamp: timestamp, Value: value };\n    } else {\n      return existing;\n    }\n  },\n};\n\nconst props = <T>(db: CRDT.Database, replica: string, ctx: CRDT.ActorContext) =>\n  CRDT.replicator(crdt, db, replica, ctx);\n\nconst update = async <T>(\n  value: T | null,\n  ref: Endpoint<T>\n): Promise<T | null> => {\n  const command: CRDT.Command<Operation<T>> = ["", [new Date(), value]];\n  const result = await ref(command);\n  return result;\n};\n\nconst query = async <T>(ref: Endpoint<T>): Promise<T | null> => {\n  const result = await ref(CRDT.Query);\n  return result;\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"How the code works:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["First, the code defines a type ",(0,s.jsx)(n.code,{children:"Timestamp"})," that represents a tuple of a ",(0,s.jsx)(n.code,{children:"Date"})," object and a ",(0,s.jsx)(n.code,{children:"string"})," that represents the replica ID. This type is used to order updates from different replicas."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The code then defines a type ",(0,s.jsx)(n.code,{children:"LWWRegister<T>"})," that represents a Last-Write-Wins Register. It consists of a ",(0,s.jsx)(n.code,{children:"Timestamp"})," and a ",(0,s.jsx)(n.code,{children:"Value"})," of type ",(0,s.jsx)(n.code,{children:"T | null"}),". The ",(0,s.jsx)(n.code,{children:"Timestamp"})," represents the last time the register was updated, and the ",(0,s.jsx)(n.code,{children:"Value"})," represents the value of the register."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The code also defines a type ",(0,s.jsx)(n.code,{children:"Operation<T>"})," that represents a tuple of a ",(0,s.jsx)(n.code,{children:"Date"})," object and a ",(0,s.jsx)(n.code,{children:"Value"})," of type ",(0,s.jsx)(n.code,{children:"T | null"}),". This is used to represent update operations on the register."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The code defines a type ",(0,s.jsx)(n.code,{children:"Endpoint<T>"})," that represents a CRDT endpoint for an LWWRegister of type ",(0,s.jsx)(n.code,{children:"T"}),". This type is defined using the ",(0,s.jsx)(n.code,{children:"CRDT.Endpoint"})," type provided by the CRDT library."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The code then defines a constant ",(0,s.jsx)(n.code,{children:"crdt"})," that is an instance of the CRDT type. It implements the ",(0,s.jsx)(n.code,{children:"Default"}),", ",(0,s.jsx)(n.code,{children:"Query"}),", ",(0,s.jsx)(n.code,{children:"Prepare"}),", and ",(0,s.jsx)(n.code,{children:"Effect"})," methods of the CRDT interface."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Default"})," method returns a default value for the register, which is a timestamp of the earliest possible time and an empty string for the replica ID, and a ",(0,s.jsx)(n.code,{children:"null"})," value."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Query"})," method simply returns the current value of the register."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Prepare"})," method takes a timestamp and a value, and returns them as a tuple representing an update operation."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Effect"})," method takes the existing state of the register and an update operation, and returns the new state of the register. It compares the timestamps of the existing state and the update operation, and returns the state with the more recent timestamp and value."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"props"})," function takes a database, a replica ID, and an actor context, and returns a replicator function for the LWWRegister."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"update"})," function takes a value and an endpoint reference, and returns a promise that resolves to the updated value of the register. It creates a command object that represents the update operation, sends the command to the endpoint, and waits for the response."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"query"})," function takes an endpoint reference, and returns a promise that resolves to the current value of the register. It sends a query command to the endpoint and waits for the response."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"sample-scenario",children:"Sample scenario"}),"\n",(0,s.jsx)(n.p,{children:"Let's say you're building a real-time collaborative document editing application, where multiple users can edit the same document simultaneously. In this application, you need to maintain a Last-Write-Wins Register CRDT to keep track of the last modification made to each section of the document."}),"\n",(0,s.jsx)(n.p,{children:"In this case, you can represent each section of the document as a key-value pair, where the key is the section ID and the value is a Last-Write-Wins Register that keeps track of the last modification made to that section. When a user wants to make a modification to a section of the document, you can use the Last-Write-Wins Register CRDT to ensure that the latest modification wins."}),"\n",(0,s.jsx)(n.p,{children:"Here's a sample:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Alice and Bob are working on the same document simultaneously. Alice is editing Section A, while Bob is editing Section B."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Alice finishes editing Section A and saves her changes. The Last-Write-Wins Register for Section A is updated with Alice's changes."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Bob finishes editing Section B and saves his changes. The Last-Write-Wins Register for Section B is updated with Bob's changes."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Bob realizes that he needs to make some changes to Section A, which Alice had already edited earlier. Bob retrieves the current value of the Last-Write-Wins Register for Section A and sees Alice's changes."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Bob makes his changes to Section A and attempts to save them. However, before Bob's changes can be saved, Alice makes some additional changes to Section A and saves them. The Last-Write-Wins Register for Section A is updated with Alice's latest changes."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"When Bob attempts to save his changes to Section A again, the Last-Write-Wins Register CRDT resolves the conflict and ensures that Alice's latest changes win. Bob's changes are discarded, and the Last-Write-Wins Register for Section A is updated with Alice's latest changes."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"multi-value-register-mv-register",children:"Multi Value Register (MV Register)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"MV Register",src:t(8161).Z+"",width:"926",height:"249"}),"\nMV Register (state-based)"]}),"\n",(0,s.jsxs)(n.p,{children:["Ref: ",(0,s.jsx)(n.a,{href:"https://inria.hal.science/inria-00555588/document",children:"A comprehensive study of Convergent and Commutative Replicated Data Types"})]}),"\n",(0,s.jsx)(n.h3,{id:"example-code-1",children:"Example code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'type Change = {\n  user: string;\n  text: string;\n};\n\ntype DocVersion = {\n  timestamp: Date;\n  changes: Change[];\n};\n\ntype MVRegister = DocVersion[];\n\ntype Endpoint = CRDT.Endpoint<MVRegister, DocVersion[], DocVersion[], Change>;\n\nconst crdt: CRDT.Crdt<MVRegister, DocVersion[], DocVersion[], Change> = {\n  Default: [],\n  Query: (crdt) => crdt.flatMap((v) => v.changes),\n  Prepare: (_, value) => [{ timestamp: new Date(), changes: [value] }],\n  Effect: (existing, e) => {\n    const newVersion: DocVersion = {\n      timestamp: new Date(),\n      changes: [...existing[existing.length - 1].changes, e],\n    };\n    return [...existing, newVersion];\n  },\n};\n\nconst props = (db: CRDT.Database, replica: string, ctx: CRDT.ActorContext) =>\n  CRDT.replicator(crdt, db, replica, ctx);\n\nconst update = async (change: Change, ref: Endpoint): Promise<DocVersion[]> => {\n  const command: CRDT.Command<Change> = ["", change];\n  const result = await ref(command);\n  return result;\n};\n\nconst query = async (ref: Endpoint): Promise<Change[]> => {\n  const result = await ref(CRDT.Query);\n  return result;\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"** How code work **"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Define the ",(0,s.jsx)(n.code,{children:"MVRegister"})," type alias which represents a list of tuples containing a version timestamp and an optional value of type ",(0,s.jsx)(n.code,{children:"T"}),". This is the actual CRDT data structure that we'll be manipulating."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Define the ",(0,s.jsx)(n.code,{children:"Endpoint"})," type alias which represents the client's view of the CRDT. It is essentially a wrapper around the CRDT operations, providing a simplified interface for clients to interact with."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Define the ",(0,s.jsx)(n.code,{children:"crdt"})," constant which contains the implementation of the CRDT. It is an object literal that implements the ",(0,s.jsx)(n.code,{children:"Crdt"})," interface. It defines the ",(0,s.jsx)(n.code,{children:"Default"})," member which returns an empty ",(0,s.jsx)(n.code,{children:"MVRegister"}),", the ",(0,s.jsx)(n.code,{children:"Query"})," member which returns a list of non-null values in the CRDT, the ",(0,s.jsx)(n.code,{children:"Prepare"})," member which simply returns the given value as-is, and the ",(0,s.jsx)(n.code,{children:"Effect"})," member which merges the given event with the existing CRDT state."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Define the ",(0,s.jsx)(n.code,{children:"props"})," function which creates a new CRDT endpoint using the given database, replica ID, and actor context. It does this by calling the ",(0,s.jsx)(n.code,{children:"replicator"})," function with the ",(0,s.jsx)(n.code,{children:"crdt"})," object and the given parameters."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Define the ",(0,s.jsx)(n.code,{children:"update"})," function which updates the CRDT with the given value by creating a new command with the value and sending it to the endpoint. It returns a promise that resolves with the updated value."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Define the ",(0,s.jsx)(n.code,{children:"query"})," function which retrieves the current state of the CRDT by sending a ",(0,s.jsx)(n.code,{children:"Query"})," command to the endpoint. It returns a promise that resolves with the list of non-null values in the CRDT."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},3477:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/lwwRegisterStateBased-085584d9a22eb3b40a670d295d214186.png"},8161:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/mvRegisterStateBased-906cbab0edd093f612ed9ab62eea6f82.png"},1151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>a});var s=t(7294);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);