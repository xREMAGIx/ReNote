"use strict";(self.webpackChunkrenote=self.webpackChunkrenote||[]).push([[1083],{2960:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var s=n(5893),i=n(1151);const o={sidebar_position:1},a="Definition",r={id:"crdt/definition",title:"Definition",description:"Conflict-free Replicated Data Type (CRDT)",source:"@site/docs/crdt/definition.md",sourceDirName:"crdt",slug:"/crdt/definition",permalink:"/renote/docs/crdt/definition",draft:!1,unlisted:!1,editUrl:"https://github.com/xREMAGIx/renote/tree/main/docs/crdt/definition.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"CRDT",permalink:"/renote/docs/category/crdt"},next:{title:"Objects and Operations",permalink:"/renote/docs/crdt/objects-and-operations"}},l={},c=[{value:"Conflict-free Replicated Data Type (CRDT)",id:"conflict-free-replicated-data-type-crdt",level:2},{value:"Consistency (TODO)",id:"consistency-todo",level:2},{value:"Eventual Consistency (EC)",id:"eventual-consistency-ec",level:3},{value:"Strong Eventual Consistency (SEC)",id:"strong-eventual-consistency-sec",level:3},{value:"Strong Consistency",id:"strong-consistency",level:3},{value:"Comparison",id:"comparison",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"definition",children:"Definition"}),"\n",(0,s.jsx)(t.h2,{id:"conflict-free-replicated-data-type-crdt",children:"Conflict-free Replicated Data Type (CRDT)"}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.strong,{children:"Conflict-free Replicated Data Type (CRDT)"})," is a data structure that simplifies distributed data storage systems and multi-user applications.\nIn many systems, copies of some data need to be stored on multiple computers (known as ",(0,s.jsx)(t.strong,{children:"replicas"}),"). Examples of such systems include:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Mobile apps that store data on the local device, and that need to sync that data to other devices belonging to the same user (such as calendars, notes, contacts, or reminders);"}),"\n",(0,s.jsx)(t.li,{children:"Distributed databases, which maintain multiple replicas of the data (in the same datacenter or in different locations) so that the system continues working correctly if some of the replicas are offline;"}),"\n",(0,s.jsx)(t.li,{children:"Collaboration software, such as Google Docs, Trello, Figma, or many others, in which several users can concurrently make changes to the same file or data;"}),"\n",(0,s.jsx)(t.li,{children:"Large-scale data storage and processing systems, which replicate data in order to achieve global scalability."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Ref: ",(0,s.jsx)(t.a,{href:"https://crdt.tech",children:"CRDT Tech"})]}),"\n",(0,s.jsx)(t.h2,{id:"consistency-todo",children:"Consistency (TODO)"}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:["Resource: ",(0,s.jsx)(t.a,{href:"https://stackoverflow.com/questions/29381442/eventual-consistency-vs-strong-eventual-consistency-vs-strong-consistency",children:'"Eventual Consistency" vs "Strong Eventual Consistency" vs "Strong Consistency" - StackOverflow'})]})}),"\n",(0,s.jsx)(t.h3,{id:"eventual-consistency-ec",children:"Eventual Consistency (EC)"}),"\n",(0,s.jsx)(t.p,{children:"Conflicts can arise, but nodes communicate each other their changes to solve those conflicts, so in time they agree upon the definitive value. Thus, if no more changes are applied to the data for a certain period, then all nodes will agree in the data value (i.e. they will eventually agree) so readers of data will eventually see the same value."}),"\n",(0,s.jsx)(t.p,{children:"Example:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Two nodes A and B (nA\xa0and\xa0nB) have each one copy of a string, which is update with operations\xa0",(0,s.jsx)(t.code,{children:"read()"}),"\xa0and\xa0",(0,s.jsx)(t.code,{children:"write(string)"}),". Let's say each one has its own client (cliA\xa0and\xa0cliB)."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:['Let\'s say that initially both nodes store the same value "Joe", but at some moment\xa0nA\xa0updates it to "Frank" (calls\xa0',(0,s.jsx)(t.code,{children:'write("Frank")'}),")."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:'Then\xa0nA\xa0will tell\xa0nB\xa0that the value has been updated; as both values differ a conflict has arisen but in can be solved using some policy (for example last-write-wins) so\xa0nB\xa0finally updates its record also to "Frank".'}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Before the conflict is resolved\xa0cliAand\xa0cliB\xa0will see different versions of the data (the\xa0",(0,s.jsx)(t.code,{children:"read()"}),"\xa0op result will differ), but eventually both will see the same value again."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Keep in mind that if both nodes update their value simultaneously then conflict resolution is still possible but more complicated. This is where SEC shines."}),"\n",(0,s.jsx)(t.h3,{id:"strong-eventual-consistency-sec",children:"Strong Eventual Consistency (SEC)"}),"\n",(0,s.jsx)(t.p,{children:"This is a special case of EC, that is valid only for certain data types."}),"\n",(0,s.jsx)(t.p,{children:"Example:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Let's assume that the data object shared is a counter, and updates are made by add(int value) and substract(int value) operations. In this case, the order in which we apply updates does not matter!"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"So if both nA and nB start with a counter value of 0, and if then nA runs add(10) and nB runs substract(5) (simultaneosly), they only need to send the update operation to each other without caring for conflict resolution, eventually it is ensured that they will reach the same value (remember that, in contrast, in the previous example for EC some conflict resolution could be required)!"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"strong-consistency",children:"Strong Consistency"}),"\n",(0,s.jsxs)(t.p,{children:["Quite different to the other two. Here it is a requirement that upon update operations all nodes agree on the new value before making the new value visible to clients. That way updates are visible to all clients 'at the same time', so they will read the same value at all times. Now this introduces the requirement for some blocking in update operations. Both in EC and SEC an update operation was over as soon as the local copy was updated (then the operation was broadcasted to the other nodes). Here a client update does not return until all nodes have agreed upon the data value, and while this is done all accesses to any copy of that data are 'locked' (so other clients reads are blocked). In our example for EC, if\xa0cliA\xa0runs\xa0",(0,s.jsx)(t.code,{children:'write("Frank")'}),",\xa0cliA\xa0will be blocked until the update is agreed by both\xa0nA\xa0and\xa0nB, and then it will made visible for both\xa0cliA\xa0and\xa0cliB\xa0at the same time, i.e. the\xa0",(0,s.jsx)(t.code,{children:"read()"}),"\xa0operation should return the same value from then on."]}),"\n",(0,s.jsx)(t.h3,{id:"comparison",children:"Comparison"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://www.baeldung.com/cs/eventual-consistency-vs-strong-eventual-consistency-vs-strong-consistency",children:"TODO"}),"\n",(0,s.jsx)(t.a,{href:"https://stackoverflow.com/questions/29381442/eventual-consistency-vs-strong-eventual-consistency-vs-strong-consistency",children:"TODO2"})]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>a});var s=n(7294);const i={},o=s.createContext(i);function a(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);