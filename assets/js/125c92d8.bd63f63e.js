"use strict";(self.webpackChunkrenote=self.webpackChunkrenote||[]).push([[1698],{4669:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var n=a(5893),s=a(1151);const r={sidebar_position:5},i="Relation between CvRDT and CmRDT",o={id:"crdt/relation-cvrdt-cmrdt",title:"Relation between CvRDT and CmRDT",description:"Differences",source:"@site/docs/crdt/relation-cvrdt-cmrdt.mdx",sourceDirName:"crdt",slug:"/crdt/relation-cvrdt-cmrdt",permalink:"/renote/docs/crdt/relation-cvrdt-cmrdt",draft:!1,unlisted:!1,editUrl:"https://github.com/xREMAGIx/renote/tree/main/docs/crdt/relation-cvrdt-cmrdt.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Operation-based Commutative Replicated Data Type (CmRDT)",permalink:"/renote/docs/crdt/op-based-crdt"},next:{title:"Types Of CRDT",permalink:"/renote/docs/crdt/types-of-crdt"}},d={},c=[{value:"Differences",id:"differences",level:2},{value:"Operation-based emulation of a state-based object",id:"operation-based-emulation-of-a-state-based-object",level:2},{value:"State-based emulation of an operation-based object",id:"state-based-emulation-of-an-operation-based-object",level:2}];function l(e){const t={a:"a",h1:"h1",h2:"h2",img:"img",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"relation-between-cvrdt-and-cmrdt",children:"Relation between CvRDT and CmRDT"}),"\n",(0,n.jsx)(t.h2,{id:"differences",children:"Differences"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Criteria"}),(0,n.jsx)(t.th,{children:"Operation-based CRDTs"}),(0,n.jsx)(t.th,{children:"State-based CRDTs"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Representation of updates"}),(0,n.jsx)(t.td,{children:"A sequence of operations"}),(0,n.jsx)(t.td,{children:"A complete copy of the data structure's state"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Propagation of updates"}),(0,n.jsx)(t.td,{children:"Propagate individual operations"}),(0,n.jsx)(t.td,{children:"Propagate the entire state"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Convergence"}),(0,n.jsx)(t.td,{children:"Same sequence of operations in the same order"}),(0,n.jsx)(t.td,{children:"Associative, commutative, and idempotent merge function"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Memory overhead"}),(0,n.jsx)(t.td,{children:"Lower memory overhead"}),(0,n.jsx)(t.td,{children:"Higher memory overhead"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Network overhead"}),(0,n.jsx)(t.td,{children:"Higher network overhead"}),(0,n.jsx)(t.td,{children:"Lower network overhead"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Applications"}),(0,n.jsx)(t.td,{children:"Systems that require low memory overhead and fast convergence"}),(0,n.jsx)(t.td,{children:"Systems that require low network overhead and simpler merge functions"})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"operation-based-emulation-of-a-state-based-object",children:"Operation-based emulation of a state-based object"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"spec Op based Emulate State based",src:a(8577).Z+"",width:"1668",height:"517"})}),"\n",(0,n.jsx)(t.p,{children:"Interestingly, it is always possible to emulate a state-based object using the operation-based approach, and vice-versa."}),"\n",(0,n.jsx)(t.p,{children:"In specification above, we show operation-based emulation of a state-based object (taking some liberties with notation). Ignoring queries (which pose no problems), the emulating operation- based object has a single update that computes some state-based update (after checking for its precondition) and performs merge downstream. The downstream precondition is empty because merge must be enabled in any reachable state. The emulation does not make use of compare."}),"\n",(0,n.jsx)(t.p,{children:"If the base object is a CvRDT, then merge operations commute, and the emulated object is a CmRDT."}),"\n",(0,n.jsxs)(t.p,{children:["Ref: ",(0,n.jsx)(t.a,{href:"https://inria.hal.science/inria-00555588/document",children:"A comprehensive study of Convergent and Commutative Replicated Data Types"})]}),"\n",(0,n.jsx)(t.h2,{id:"state-based-emulation-of-an-operation-based-object",children:"State-based emulation of an operation-based object"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"spec State based Emulate Op based",src:a(9430).Z+"",width:"1666",height:"905"})}),"\n",(0,n.jsx)(t.p,{children:"State-based emulation of an operation-based object essentially formalises the mechanics of an epidemic reliable broadcast, as shown in Spec. 4 (taking some liberties with notation)."}),"\n",(0,n.jsx)(t.p,{children:"Again, we ignore queries, which pose no problems. Calling an operation-based update adds it to a set of M messages to be delivered; merge takes the union of the two message sets."}),"\n",(0,n.jsx)(t.p,{children:"When an update\u2019s downstream precondition is true, the corresponding message is delivered by executing the downstream part of the update. In order to avoid duplicate deliveries, delivered messages are stored in a set D."}),"\n",(0,n.jsx)(t.p,{children:"The states of the emulating object form a monotonic semilattice. Calling or delivering an operation adds it to the relevant message set, and therefore advances the state in the partial order. merge is defined to take the union of the M sets, and is thus a LUB operation. Remark that M is identical to the causal history of the replica; non-concurrent updates appear in M in causal order. If the emulated op-based object is a CmRDT, then delivery order is satisfied. Concurrent operations appear in M in any order; if the emulated object is a CmRDT, they commute. Therefore, after two replicas merge mutually, their D sets are identical and their P payloads have equivalent state."}),"\n",(0,n.jsxs)(t.p,{children:["Ref: ",(0,n.jsx)(t.a,{href:"https://inria.hal.science/inria-00555588/document",children:"A comprehensive study of Convergent and Commutative Replicated Data Types"})]})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8577:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/opBasedEmulateStateBased-8c594d0d1dc0d877b2597b9c8966ec6d.png"},9430:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/stateBasedEmulateOpBased-b5837a3e5ea4ea24f91d8a540eb46990.png"},1151:(e,t,a)=>{a.d(t,{Z:()=>o,a:()=>i});var n=a(7294);const s={},r=n.createContext(s);function i(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);